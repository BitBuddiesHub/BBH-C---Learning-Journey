# 冒泡排序实现与逻辑详解

## 代码

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 冒泡排序函数
void bubbleSort(vector<int>& arr) {
    int n = arr.size();
    // 外层循环控制趟数，共 n-1 趟
    for (int i = 0; i < n - 1; i++) {
        // 内层循环控制每一趟的比较次数
        for (int j = 0; j < n - 1 - i; j++) {
            // 如果当前元素比下一个元素大，交换两者
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}

int main() {
    vector<int> arr = {64, 34, 25, 12, 22, 11, 90};
    bubbleSort(arr);
    for (int num : arr) {
        cout << num << " ";
    }
    return 0;
}
```

---

## 逻辑分析

### **功能**
冒泡排序是一种简单的排序算法，通过反复比较相邻元素并交换，将最大或最小的元素逐步“冒泡”到数组的一端。

### **代码结构**
1. **`bubbleSort` 函数**:
   - 接受一个 `vector<int>` 引用作为参数，对其进行排序。
   - 外层循环控制比较轮数。
   - 内层循环控制每轮中的比较次数。
   - 使用 `swap` 函数交换位置不正确的元素。

2. **`main` 函数**:
   - 创建一个整数数组。
   - 调用 `bubbleSort` 函数进行排序。
   - 输出排序后的数组。

---

## 步骤与逻辑

### **1. 外层循环**
```cpp
for (int i = 0; i < n - 1; i++) {
```
- **作用**: 控制排序轮数。
- **逻辑**: 对于一个大小为 `n` 的数组，最多需要 `n-1` 轮比较。
- 每完成一轮，当前轮次的最大元素就会被“冒泡”到数组末尾，因此下一轮的比较范围减少。

### **2. 内层循环**
```cpp
for (int j = 0; j < n - 1 - i; j++) {
```
- **作用**: 在每一轮中比较相邻元素。
- **逻辑**: 
  - `n-1-i` 确保已经排序的部分不再参与比较。
  - 每次比较两个相邻元素，若顺序不正确，则交换。

### **3. 交换逻辑**
```cpp
if (arr[j] > arr[j + 1]) {
    swap(arr[j], arr[j + 1]);
}
```
- **作用**: 通过比较和交换，将较大的元素移动到数组的后部。
- **逻辑**:
  - 如果当前元素大于下一个元素，交换两者。
  - 每次交换都会将未排序部分的最大值逐步推向末尾。

### **4. 输出结果**
```cpp
for (int num : arr) {
    cout << num << " ";
}
```
- 遍历排序后的数组并输出结果。

---

## 示例运行过程

假设输入数组为 `{64, 34, 25, 12, 22, 11, 90}`：

### 第 1 轮
比较范围：`0 ~ 6`。

| 比较下标 | 比较元素 | 交换 | 结果                |
| -------- | -------- | ---- | ------------------- |
| 0, 1     | 64, 34   | 是   | `{34, 64, 25, 12, 22, 11, 90}` |
| 1, 2     | 64, 25   | 是   | `{34, 25, 64, 12, 22, 11, 90}` |
| 2, 3     | 64, 12   | 是   | `{34, 25, 12, 64, 22, 11, 90}` |
| 3, 4     | 64, 22   | 是   | `{34, 25, 12, 22, 64, 11, 90}` |
| 4, 5     | 64, 11   | 是   | `{34, 25, 12, 22, 11, 64, 90}` |
| 5, 6     | 64, 90   | 否   | `{34, 25, 12, 22, 11, 64, 90}` |

**第 1 轮结果**: 最大值 `90` 被移动到末尾。

---

### 第 2 轮
比较范围：`0 ~ 5`。

| 比较下标 | 比较元素 | 交换 | 结果                |
| -------- | -------- | ---- | ------------------- |
| 0, 1     | 34, 25   | 是   | `{25, 34, 12, 22, 11, 64, 90}` |
| 1, 2     | 34, 12   | 是   | `{25, 12, 34, 22, 11, 64, 90}` |
| 2, 3     | 34, 22   | 是   | `{25, 12, 22, 34, 11, 64, 90}` |
| 3, 4     | 34, 11   | 是   | `{25, 12, 22, 11, 34, 64, 90}` |

**第 2 轮结果**: 次大值 `64` 移动到倒数第二位。

---

### 依此类推...
最终结果：
```
11 12 22 25 34 64 90
```

---

## 复杂度分析

### 时间复杂度
- **最坏情况**: \( O(n^2) \)
  - 需要 \( n-1 \) 趟比较，每趟最多 \( n-i-1 \) 次操作。
- **最优情况**: \( O(n^2) \)
  - 当前实现未优化，最优情况下仍然需要 \( O(n^2) \)。

### 空间复杂度
- **额外空间**: \( O(1) \)
  - 直接在原数组上操作。

---

## 优化建议

1. **添加标志位**:
   - 如果某一轮未发生交换，说明数组已排序，可以提前退出。

```cpp
void bubbleSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; i++) {
        bool swapped = false; // 标志位
        for (int j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        if (!swapped) break; // 提前退出
    }
}
```

2. **改进时间复杂度**:
   - 优化到 \( O(n) \) 的最优情况。

---

## 总结

| 优点                  | 缺点                          |
| --------------------- | ----------------------------- |
| 简单易实现            | 时间复杂度较高，效率低         |
| 适用于小规模数据集     | 不适合大规模数据集             |

冒泡排序是一种适合学习的入门排序算法，在实际应用中，可使用更高效的排序方法（如快速排序或归并排序）。
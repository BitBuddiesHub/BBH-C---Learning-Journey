# 桶排序（Bucket Sort）实现与逻辑详解

## 代码

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // for sort()
using namespace std;

// 桶排序函数
void bucketSort(vector<float>& arr) {
    int n = arr.size();
    vector<vector<float>> buckets(n); // 创建 n 个桶

    // 将元素分配到桶中
    for (float num : arr) {
        int bucketIndex = n * num; // 根据范围计算桶索引
        buckets[bucketIndex].push_back(num);
    }

    // 对每个桶进行排序
    for (int i = 0; i < n; i++) {
        sort(buckets[i].begin(), buckets[i].end());
    }

    // 合并所有桶中的元素
    int index = 0;
    for (int i = 0; i < n; i++) {
        for (float num : buckets[i]) {
            arr[index++] = num;
        }
    }
}

int main() {
    vector<float> arr = {0.897, 0.565, 0.656, 0.123, 0.665, 0.343};
    bucketSort(arr);
    for (float num : arr) {
        cout << num << " ";
    }
    return 0;
}
```

---

## 逻辑分析

### **功能**
桶排序是一种分配式排序算法，适用于均匀分布的浮点数排序。它通过将元素划分到不同的桶中，每个桶独立排序，最后将桶中的元素合并。

---

## 步骤与逻辑

### **1. 创建桶**
```cpp
vector<vector<float>> buckets(n);
```
- 创建了一个二维向量，包含 `n` 个空桶。
- 每个桶用于存储分配到特定范围内的浮点数。

---

### **2. 分配元素到桶中**
```cpp
for (float num : arr) {
    int bucketIndex = n * num; // 根据范围计算桶索引
    buckets[bucketIndex].push_back(num);
}
```
- 通过 `n * num` 计算桶索引，将每个浮点数分配到对应的桶。
- **逻辑**: 假设输入范围是 `[0, 1)`，乘以 `n` 后可以将浮点数映射到桶的索引范围 `[0, n-1]`。

#### 示例
输入数组：`{0.897, 0.565, 0.656, 0.123, 0.665, 0.343}`  
计算的桶索引如下：

| 元素       | 计算过程        | 桶索引  |
| ---------- | --------------- | ------- |
| `0.897`    | `6 * 0.897 = 5` | `5`     |
| `0.565`    | `6 * 0.565 = 3` | `3`     |
| `0.656`    | `6 * 0.656 = 3` | `3`     |
| `0.123`    | `6 * 0.123 = 0` | `0`     |
| `0.665`    | `6 * 0.665 = 3` | `3`     |
| `0.343`    | `6 * 0.343 = 2` | `2`     |

分配结果：
```
buckets[0]: {0.123}
buckets[2]: {0.343}
buckets[3]: {0.565, 0.656, 0.665}
buckets[5]: {0.897}
```

---

### **3. 对每个桶排序**
```cpp
for (int i = 0; i < n; i++) {
    sort(buckets[i].begin(), buckets[i].end());
}
```
- 使用 `std::sort` 对每个桶内的元素进行独立排序。
- 桶内排序时间复杂度依赖于桶中元素的数量，通常为 \( O(k \log k) \)，其中 \( k \) 是桶内的元素个数。

#### 示例
对上面的桶进行排序：
```
buckets[0]: {0.123}
buckets[2]: {0.343}
buckets[3]: {0.565, 0.656, 0.665}
buckets[5]: {0.897}
```
结果不变，因为每个桶的元素已经是有序的。

---

### **4. 合并桶中的元素**
```cpp
int index = 0;
for (int i = 0; i < n; i++) {
    for (float num : buckets[i]) {
        arr[index++] = num;
    }
}
```
- 遍历每个桶，将桶内的元素依次合并回原数组。
- **逻辑**: 桶按索引顺序排列，且每个桶内元素已排序，合并时无需再排序。

#### 示例
合并结果：
```
arr = {0.123, 0.343, 0.565, 0.656, 0.665, 0.897}
```

---

## 示例运行过程

初始数组：
```
{0.897, 0.565, 0.656, 0.123, 0.665, 0.343}
```

1. **分配到桶**:
```
buckets[0]: {0.123}
buckets[2]: {0.343}
buckets[3]: {0.565, 0.656, 0.665}
buckets[5]: {0.897}
```

2. **对每个桶排序**:
```
buckets[0]: {0.123}
buckets[2]: {0.343}
buckets[3]: {0.565, 0.656, 0.665}
buckets[5]: {0.897}
```

3. **合并所有桶**:
```
{0.123, 0.343, 0.565, 0.656, 0.665, 0.897}
```

最终输出：
```
0.123 0.343 0.565 0.656 0.665 0.897
```

---

## 复杂度分析

### 时间复杂度
1. **分配到桶**: \( O(n) \)  
   - 每个元素分配一次。

2. **桶内排序**: \( O(k \log k) \)，累计为 \( O(n \log n) \)  
   - \( k \) 是桶内元素数目。

3. **合并桶**: \( O(n) \)  
   - 遍历每个桶并复制元素。

**总时间复杂度**:  
- **平均情况**: \( O(n + n \log k) \)，\( k \) 为单个桶的平均元素数量。
- **最坏情况**: \( O(n^2) \) （当所有元素集中在一个桶中）。

### 空间复杂度
- 额外的桶空间: \( O(n) \)。
- 总空间复杂度: \( O(n) \)。

---

## 适用场景

1. **输入均匀分布**:
   - 桶排序最适合处理分布均匀的浮点数或整数。
2. **输入范围明确**:
   - 例如 `[0, 1)` 范围的浮点数。

---

## 优点与缺点

### 优点
- 简单易实现。
- 在输入数据均匀分布时效率高，接近线性时间 \( O(n) \)。

### 缺点
- 不适用于数据分布极端或范围不均的场景。
- 需要额外的空间存储桶。

---

## 总结

桶排序是一种高效的分配式排序算法，在特定场景下能实现接近线性时间复杂度。通过分配桶、桶内排序和合并，能够快速完成排序任务。实际使用时，应根据输入数据分布特性判断是否适用。
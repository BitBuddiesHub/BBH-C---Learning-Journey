# 选择排序（Selection Sort）实现与逻辑详解

## 代码

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 选择排序函数
void selectionSort(vector<int>& arr) {
    int n = arr.size();
    // 外层循环：遍历数组的每个元素作为未排序部分的最小值
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i; // 假设当前索引为最小值
        // 内层循环：找到未排序部分的最小值
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j; // 更新最小值索引
            }
        }
        // 将未排序部分的最小值交换到前面
        swap(arr[i], arr[minIndex]);
    }
}

int main() {
    vector<int> arr = {64, 25, 12, 22, 11};
    selectionSort(arr);
    for (int num : arr) {
        cout << num << " ";
    }
    return 0;
}
```

---

## 逻辑分析

### **功能**
选择排序是一种简单直观的排序算法。它每次从未排序部分找到最小值，并将其交换到已排序部分的末尾。

---

## 步骤与逻辑

### **1. 外层循环**

```cpp
for (int i = 0; i < n - 1; i++) {
```
- **逻辑**:
  - 遍历数组的每个元素，将其视为当前未排序部分的最小值。
  - 总共需要 \( n-1 \) 轮迭代。

---

### **2. 找到未排序部分的最小值**

```cpp
int minIndex = i;
for (int j = i + 1; j < n; j++) {
    if (arr[j] < arr[minIndex]) {
        minIndex = j;
    }
}
```
- **逻辑**:
  - 从当前索引 \( i \) 开始，向后扫描未排序部分。
  - 找到比当前最小值更小的元素，更新最小值的索引。

---

### **3. 交换最小值到前面**

```cpp
swap(arr[i], arr[minIndex]);
```
- **逻辑**:
  - 将未排序部分的最小值与当前未排序部分的第一个元素交换。
  - 确保当前元素及其前面的部分已排序。

---

## 示例运行过程

初始数组：
```
{64, 25, 12, 22, 11}
```

### 第 1 轮
- **未排序部分**: `{64, 25, 12, 22, 11}`
- 找到最小值：`11`，索引为 `4`
- 交换 `64` 和 `11`
- **结果**: `{11, 25, 12, 22, 64}`

---

### 第 2 轮
- **未排序部分**: `{25, 12, 22, 64}`
- 找到最小值：`12`，索引为 `2`
- 交换 `25` 和 `12`
- **结果**: `{11, 12, 25, 22, 64}`

---

### 第 3 轮
- **未排序部分**: `{25, 22, 64}`
- 找到最小值：`22`，索引为 `3`
- 交换 `25` 和 `22`
- **结果**: `{11, 12, 22, 25, 64}`

---

### 第 4 轮
- **未排序部分**: `{25, 64}`
- 找到最小值：`25`，索引为 `3`
- 无需交换
- **结果**: `{11, 12, 22, 25, 64}`

最终排序结果：
```
{11, 12, 22, 25, 64}
```

---

## 复杂度分析

### 时间复杂度
1. **最坏情况**: \( O(n^2) \)
   - 每轮扫描未排序部分的所有元素。
2. **最优情况**: \( O(n^2) \)
   - 即使数组已排序，仍需扫描所有元素。
3. **平均情况**: \( O(n^2) \)

### 空间复杂度
- 原地排序，无需额外空间：\( O(1) \)

---

## 适用场景

1. **小规模数组排序**:
   - 适用于元素较少的数组。
2. **需要稳定内存占用**:
   - 因为选择排序的空间复杂度为 \( O(1) \)，适合内存限制较严的场景。

---

## 优点与缺点

### 优点
- 实现简单，逻辑清晰。
- 原地排序，空间复杂度低。

### 缺点
- 时间复杂度较高，不适合大规模数组。
- 不稳定排序：相等元素的相对顺序可能改变。

---

## 总结

选择排序是一种直观易懂的排序算法，尽管时间复杂度为 \( O(n^2) \)，但其实现简单且无需额外空间。对于小规模数据或内存紧张的场景，选择排序是一个可行的选择。
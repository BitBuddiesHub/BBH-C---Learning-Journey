# 插入排序（Insertion Sort）实现与逻辑详解

## 代码

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 插入排序函数
void insertionSort(vector<int>& arr) {
    int n = arr.size();
    // 从第二个元素开始，逐个插入
    for (int i = 1; i < n; i++) {
        int key = arr[i]; // 当前要插入的元素
        int j = i - 1;
        // 将比 key 大的元素向右移动
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        // 将 key 插入到正确位置
        arr[j + 1] = key;
    }
}

int main() {
    vector<int> arr = {12, 11, 13, 5, 6};
    insertionSort(arr);
    for (int num : arr) {
        cout << num << " ";
    }
    return 0;
}
```

---

## 逻辑分析

### **功能**
插入排序是一种简单直观的排序算法，它通过逐步构建有序序列，将每个新元素插入到已排序序列的正确位置中。

---

## 步骤与逻辑

### **1. 外层循环**
```cpp
for (int i = 1; i < n; i++) {
```
- **作用**: 从第二个元素开始（下标 `1`），逐个取出元素插入到前面的已排序部分。
- **范围**: 遍历整个数组，共执行 \( n-1 \) 次。

---

### **2. 当前要插入的元素**
```cpp
int key = arr[i];
```
- **逻辑**: 当前元素 `arr[i]` 是待插入的元素。
- 通过比较，将其插入到已排序序列的合适位置。

---

### **3. 内层循环**
```cpp
while (j >= 0 && arr[j] > key) {
    arr[j + 1] = arr[j];
    j--;
}
```
- **逻辑**:
  - 从已排序序列的末尾开始，逐个比较。
  - 如果当前元素 `arr[j]` 比 `key` 大，将其向右移动一位。
- **终止条件**:
  - 已排序序列的起始位置（`j < 0`）。
  - 当前元素小于等于 `key`。

---

### **4. 插入元素**
```cpp
arr[j + 1] = key;
```
- **逻辑**: 当 `key` 找到正确的位置后，将其插入。

---

## 示例运行过程

初始数组：
```
{12, 11, 13, 5, 6}
```

### 第 1 步: 插入元素 `11`
- 比较 `12 > 11`，右移 `12`。
- 插入 `11`：
```
{11, 12, 13, 5, 6}
```

### 第 2 步: 插入元素 `13`
- 比较 `12 < 13`，无需移动。
```
{11, 12, 13, 5, 6}
```

### 第 3 步: 插入元素 `5`
- 比较 `13 > 5`，右移 `13`。
- 比较 `12 > 5`，右移 `12`。
- 比较 `11 > 5`，右移 `11`。
- 插入 `5`：
```
{5, 11, 12, 13, 6}
```

### 第 4 步: 插入元素 `6`
- 比较 `13 > 6`，右移 `13`。
- 比较 `12 > 6`，右移 `12`。
- 比较 `11 > 6`，右移 `11`。
- 插入 `6`：
```
{5, 6, 11, 12, 13}
```

最终结果：
```
{5, 6, 11, 12, 13}
```

---

## 复杂度分析

### 时间复杂度
1. **最坏情况**: \( O(n^2) \)
   - 数组完全逆序，每次插入都需要移动所有已排序元素。
2. **最优情况**: \( O(n) \)
   - 数组已经有序，每次插入无需移动元素。
3. **平均情况**: \( O(n^2) \)
   - 每次插入需要移动大约一半的已排序元素。

### 空间复杂度
- **额外空间**: \( O(1) \)
  - 原地排序，不需要额外的存储空间。

---

## 适用场景

1. **小规模数组**:
   - 对小数据量的数组非常高效。
2. **部分有序数组**:
   - 当输入数组接近有序时，插入排序性能接近 \( O(n) \)。

---

## 优点与缺点

### 优点
- 简单易实现。
- 稳定排序算法，保持相等元素的相对顺序。
- 对小数据量或部分有序数组效率较高。

### 缺点
- 时间复杂度较高，适合小规模数组。
- 对大规模数组效率较低，不推荐。

---

## 总结

插入排序是一种直观且简单的排序算法，适合小规模或部分有序的数据集。通过逐步构建有序序列，能够有效地插入每个新元素。尽管时间复杂度为 \( O(n^2) \)，但其实现简单且稳定，是学习排序算法的理想起点。